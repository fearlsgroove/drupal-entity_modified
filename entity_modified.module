<?php

/**
 * @file
 * Hook implementations and frequently used functions for entity modified module.
 */

/**
 * Implements hook_entity_delete().
 *
 * Delete our custom stored entity modified record when the entity is deleted.
 */
function entity_modified_entity_delete($entity, $type) {
  // Attempt to delete any record we stored for the entity. We do not check
  // if it has a modified property because our knowledge of the property could
  // have occurred after we already had a record (module updates).
  db_delete('entity_modified')
      ->condition('entity_type', $type)
      ->condition('entity_id', $entity->{entity_modified_id_name($type)})
      ->execute();
}

/**
 * Implements hook_entity_insert().
 */
function entity_modified_entity_insert($entity, $type) {
  // If the module does not have a modified property that we know about then
  // insert.
  if (!entity_modified_modified_name($type)) {
    db_insert('entity_modified')
        ->fields(array(
          'entity_type' => $type,
          'entity_id' => $entity->{entity_modified_id_name($type)},
          'modified' => REQUEST_TIME,
        ))
        ->execute();
  }
}

/**
 * Implements hook_entity_update().
 */
function entity_modified_entity_update($entity, $type) {
  // If the module does not have a modified property that we know about then
  // insert or update.
  if (!entity_modified_modified_name($type)) {
    db_merge('entity_modified')
        ->key(array(
          'entity_type' => $type,
          'entity_id' => $entity->{entity_modified_id_name($type)},
        ))
        ->fields(array(
          'modified' => REQUEST_TIME,
        ))
        ->execute();
  }
}

/**
 * Retrieve the primary ID name of a supplied entity type.
 *
 * @param string $entity_type
 *   The entity type machine name to retrieve the ID of.
 *
 * @return string
 *   The primary ID property name.
 */
function entity_modified_id_name($entity_type) {
  // Do not use drupal_static() as this is called very often, and there is no
  // foreseeable reason to need to clear it during a page load.
  static $names = array();

  if (!isset($names[$entity_type])) {
    $info = entity_get_info($entity_type);
    $names[$entity_type] = $info['entity keys']['id'];
  }

  return $names[$entity_type];
}

/**
 * Retrieve the last time an entity was modified.
 */
function entity_modified_last($entity_type, $entity) {
  $name = entity_modified_modified_name($entity_type);

  // If native modified timestamp known.
  if ($name) {
    return $entity->$name;
  }

  // Retrieve entity's last modified from our custom table.
  $id = entity_modified_id_name($entity_type);
  $modified = db_query(
    'SELECT modified FROM {entity_modified} WHERE entity_type = :entity_type AND entity_id = :entity_id',
    array(':entity_type' => $entity_type, ':entity_id' => $entity->$id)
  )->fetchField();

  // If not found then insert a new record at the present time.
  if (!$modified) {
    entity_modified_entity_insert($entity, $entity_type);
    $modified = REQUEST_TIME;
  }

  return $modified;
}

/**
 * Retrieve the last modified property name.
 *
 * @param string $entity_type
 *   The entity type to retrieve the property name for.
 *
 * @return void|string
 *   Returns string if a property exists.
 */
function entity_modified_modified_name($entity_type) {
  // Do not use drupal_static() as this is called very often, and there is no
  // foreseeable reason to need to clear it during a page load.
  static $modified = array();

  if (empty($modified)) {
    drupal_alter('entity_modified_modified_name', $modified);
  }

  if (isset($modified[$entity_type])) {
    return $modified[$entity_type];
  }
}

/**
 * Implements hook_entity_modified_modified_name_alter().
 *
 * Eating own dog food, define unique identifiers for entity types this module
 * is aware of.
 */
function entity_modified_entity_modified_modified_name_alter(&$modified) {
  // Core entity types.
  $modified['comment'] = 'changed';
  $modified['node'] = 'changed';

  // File entity module.
  $modified['file'] = 'timestamp';
}

